## Weighting
|Description        |Score|
|-------------------|-----|
|Gameplay video     |15   |
|Code video         |0    |
|Good code          |15   |
|Bad code           |30   |
|Development process|20   |
|Reflection         |20   |
## Good code
Considering my weighting, it might not come as a surprise that I am dissatisfied with my overall code. Nonetheless, there were some parts I thought were good. For context, I had a goal of implementing the ability to progress through a "biome" in the form of changing generation setting and materials.  The reason for this was that other biomes will be handled by the same map generator. Thus, there had to be ways to distinguish the biomes. To do this I decided to have stage generation "instructions", and a material communicator.<br>
##### Map generation settings
The map settings are stored in txt files corresponding with each stage of the biome. If there is no available file, it will use the default settings which generate a medium sized balanced map. As of now, the forest biome progresses from stage 1-9 as the player approaches the mountain themed troll. The maps’ theme changes from deep forest to savannah like dead forest, and finally, sparse highland. To create more or overwrite settings the developer can enter a new biome name into a new portal. Then they can adjust the generation settings in the inspector, hit F5 to refresh the generation so they may see how it looks. Then finally hit F8, to save the settings. Then enter the next stage and do so for every level. This isn’t perfect, but it works for our game as it is.<br><br>If I were to rework it, I would change the system to instead take stage progression modifiers. Such that a developer can, for example, set a minimum enemy and a maximum enemy. Then the map will automatically lerp between the number of enemies depending on player progression and how far in the boss spawns.<br>
##### Map material communication
The above system was developed very early, and at time of development it was of acceptable quality to me. However, changing the maps material was delayed, and therefore developed later, when I had gotten more experience. The order of events for the material communication is:<br>Enter Portal-> Send data to Player-> Player Enters map-> MeshGenerator calls "RequestMaterialFromPlayer" with current stage progression -> MeshGen receives and updates the current mesh's materials.
![[Pasted image 20221213205133.png]]
Considering out lack of assets, I was certain I wanted to support hexadecimals as alternatives to textured materials. The values themselves are stored in three "MaterialAlts" structs within the "MapTextures" struct.  These are further placed into a list which is publicly available in the inspector. The progression is done linearly from start to end of the biome, where element 0 is the start.
![[Pasted image 20221213235226.png]]
Lars helped me simplify the math a bit by utilising ints’ automatic flooring, to remove decimals. Since no additional operations are performed after function calls, the textures could’ve just been returned as is, instead of assigning a variable. However, this seemed like an unnecessary optimisation, and this is more readable.
![[Pasted image 20221213205217.png]]
Above is the code which handles the actual material acquisition. If MaterialAlts does not contain a material or any form of hexadecimal, then it will return null. Null in this case results in the MeshGenerator using its default material to render.![[Pasted image 20221214045726.png]]<br>Above is how the selection looks in the inspector when the "MapTextureHandler" script is attached to its hitbox. As the code shows, it will prioritize given materials, but a colour can be added as well to ensure the mesh receives a texture. <br>
## Bad Code
Taking into consideration my minimal previous knowledge of Unity, and our ambitious project scope. It does not come as a surprise to me that quite a bit of bad code was created to meet our deadlines. Overall, I am not happy with the map generation part of the game program, but it mostly works as intended. However, object generation is a worse tale.
![[Pasted image 20221213193610.png]]
##### Special object spawning
The above function is an example of where the issue lies. To start off, we get the lower and upper bounds of the polygon. Afterwards, a Vector2 point is generated within these bounds. This is such that the object will spawn roughly within the same area. Then, we check if that point is within the given polygon. This function in and on its own is inefficient due to having to identify the entire outline of the polygon to ensure the object isn’t spawned inside a protrusion in the mesh. If the point is outside the polygon, retry. It does this a maximum of 200 times but will usually not do it more than a few times. This is simply terrible, and I hate it, however I see no clear alternative to the initial generation of the object. The *real* issue comes when ensuring that the newly spawned object isn’t stuck inside a bunch of trees.![[Pasted image 20221213194918.png]]
The above code takes a list of game objects, a primary game object, and the radius of avoidance. Then checks if any of the list-objects are within the "centre’s" radius, if they are then it will return a vector which can be applied to move the object away out of the radius. However, the calling is done for every "special" object, in relation to all trees on the map. Special objects are only portals and enemies but would apply to any spawned object like chests or rare encounters. It then tries to do the same thing again until a given object has no trees within its radius.<br><br>*As I am writing this however, I can see some glaring faults. Primarily, that the return vector is the inverse of the distance between the closest tree and the given object. When it should’ve instead been the remaining distance to the maximum radius. However, another alternative to this function, would be to instead utilize the earlier mentioned "IsInPolygon" function. Though this function isn’t perfect, by utilizing the outline of where the trees are spawned, instead of the trees themselves, I could’ve saved a lot of processing.*

## Reflection
##### What i have learned
During this project I have learned a lot about game development. Aside from learning about Unity and C#, I have learned a lot about the process itself. My first lesson was to lower my expectations and set more realistic goals. As a group, we came into the project with very grand plans, and we learned quickly that they would likely be impossible. Mostly due to lack of time, because of other demanding projects, but also from lack of knowledge about Unity and the language.<br><br>When it comes to Unity it felt like I was learning new features and built-in systems at every step. Coming from developing in mostly C++ and Golang, this was quite a steep curve. However, as we progressed further into the project and I became more familiar with both C# and Unity, development went a lot smoother. I am very interested in trying to develop a game with unity again, as this was the most enjoyable project I have done so far. However, I would probably give myself more time and headspace than I had this semester.<br><br>**Version control & git**
Coming into this project I considered myself quite adept at using git with branches to avoid code conflicts. However, I found that Unity set the bar very high. Merging a scene conflict is effectively impossible and must instead be avoided at all costs. This goes for any changes done to a scene and/or prefab. I learnt that this was due to how unity assigns object IDs within its metadata. Nonetheless, as with every problem, there is a solution. Stashing the local scene somewhere smart, under a different name. Then pulling the main-branch scene and manually merging in the local changes from the backup. Will eliminate the merge conflict ID issues, since Unity will assign unique IDs locally that do not conflict with the main-branch IDs.<br><br>**Teamwork**
As for teamwork I feel like we have done well. With mostly consistent meetings, and solid communication via discord, we ensured steady progress of the game. This together with a comprehensive Issue board where we delegated tasks and tracked progress. Made the development process one of the smoothest I have experienced so far.

##### What could be done better
For me my biggest regret and lesson, is to not rely on other people’s code as a foundation, and rather construct my own from scratch. As mentioned in the [[Lisence note]], I ended up significantly changing the original code. However, since the foundation was built with a different intent, I could never get it to become mine or what I wanted. The lack of direct ownership has been both stressing and frustrating. Looking back on it I see that this was more of a hindrance than help. Bottom line is that with the knowledge I have about C# after this project, I feel like I could have done a better job than the resulting product, if I had built it from scratch.<br><br>Another issue that could’ve been done better, were assets. Since I was mostly working with the automatic generation aspect of the program, I didn't focus on the asset part. By the time the MVP came around, we only had two proper textures, grass and trees. This is what lead to the homely houses, and later bushes as well as the item shop. We should've probably split tasks better and begun searching for assets early on. However, as most of our members were more inclined to work on the code, fixing the substandard assets fell on the backburner and were simply tolerated. This is something I will carry on to my next game developing project.