## Weighting
|Description        |Score|
|-------------------|-----|
|Gameplay video     |15   |
|Code video         |0    |
|Good code          |15   |
|Bad code           |30   |
|Development process|20   |
|Reflection         |20   |
## Good code
Considering my weighting, it might not come as a surprise that I am dissatisfied with my overall code. Nonetheless, there were some parts I thought were good. For context, I had a goal of implementing the ability to progress through a "biome" in the form of changing generation settings and materials.  The reason for this was that other biomes will be handled by the same map generator. Thus, there had to be ways to distinguish the biomes. To do this I decided to have stage generation "instructions", and a material communicator.<br>
##### Map generation settings
The map settings are stored in txt files corresponding with each stage of the biome. If there is no available file, it will use the default settings which generate a medium sized balanced map. As of now, the forest biome progresses from stage 1-9 as the player approaches the mountain themed “troll”. The maps’ theme changes from deep forest to savannah like dead forest, and finally, sparse highland. To create more, or overwrite settings, the developer can enter a new biome name into a new portal. Then they can adjust the generation settings in the inspector, hit F5 to refresh the generation so they may see how it looks ,before finally hit F8, to save the settings. Following this, they can enter the next stage and save custom settings for every level. This isn’t perfect, but it works for our game as it is.<br><br>If I were to rework it, I would change the script to instead receive stage progression modifiers. Such that a developer can, for example, set a minimum enemy and a maximum enemy. Then the map will automatically lerp between the number of enemies depending on player progression and how far in the boss spawns.<br>
##### Map material communication
I developed the system above at an early stage and had deemed it acceptable. However, when I developed changing the map material later, I had gained more experience. This helped me understand that storing map data in files was cumbersome and unnecessary, when they could rather be supplied directly into the inspector. For clarity, the order of events for the material communication is:<br>Enter Portal-> Send data to Player-> Player Enters map-> MeshGenerator calls "RequestMaterialFromPlayer" with current stage progression -> MeshGen receives and updates the current mesh's materials.
![](https://github.com/AxelJacobsen/FolkHorror/blob/main/Reports/Images/Pasted%20image%2020221213205133.png)
*Figure 1; Material struct*<br>
Considering our lack of assets, I was certain I wanted to support hexadecimals as alternatives to textured materials. The values themselves are stored in three "MaterialAlts" structs within the "MapTextures" struct.  These are further placed into a list which is publicly available in the inspector. The progression is done linearly from start to end of the biome, where element 0 is the start. *See figure 2 below*7

![](https://github.com/AxelJacobsen/FolkHorror/blob/main/Reports/Images/Pasted%20image%2020221213235226.png)
*Figure 2; Material Picker*<br>
Lars helped me simplify the math a bit by utilising ints’ automatic flooring, to remove decimals. Since no additional operations are performed after function calls, the textures could’ve just been returned as is, instead of assigning a variable. However, this seemed like an unnecessary optimisation, and was intentionally not implemented to make the code more readable. 
![](https://github.com/AxelJacobsen/FolkHorror/blob/main/Reports/Images/Pasted%20image%2020221213205217.png)
*Figure 3; Material parsing*<br>
Figure 3 shows the code which handles the actual material acquisition. If MaterialAlts does not contain a material or any form of hexadecimal, then it will return null. Null in this case results in the MeshGenerator using its default material to render.
![](https://github.com/AxelJacobsen/FolkHorror/blob/main/Reports/Images/Pasted%20image%2020221214045726.png)
*Figure 4; Inspector view of the forest material progression*<br>
Figure 4 displays how selecting material looks in the inspector when the "MapTextureHandler" script is attached to a portal's hitbox. As the code shows, it will prioritize given materials, but a colour can be added as well to ensure the mesh receives a texture. <br>
## Bad Code
Taking into consideration my minimal previous knowledge of Unity, and our ambitious project scope, it does not come as a surprise to me that quite a bit of bad code was created to meet our deadlines. Overall, I am not happy with the map generation part of the game program, but it mostly works as intended. However, object generation is a worse tale.
![](https://github.com/AxelJacobsen/FolkHorror/blob/main/Reports/Images/Pasted%20image%2020221213193610.png)*Figure 5; Finding a point in a polygon*<br>
##### Special object spawning
The function shown in Figure 5 is an example of where the issue lies. To start off, we get the lower and upper bounds of the polygon. Afterwards, a Vector2 point is generated within these bounds. This is so that the object will spawn roughly within the same area. Then, we check if that point is within the given polygon. This function in and on its own is inefficient due to having to identify the entire outline of the polygon to ensure the object isn’t spawned inside a protrusion in the mesh. If it returns that the point is outside the polygon, it will retry untill its inside. It does this a maximum of *200* times but will usually not do it more than a few times. This is simply terrible, and I really dislike it, however I see no clear alternative to the initial generation of the object. The *real* issue comes when ensuring that the newly spawned object isn’t stuck inside a bunch of trees.
![](https://github.com/AxelJacobsen/FolkHorror/blob/main/Reports/Images/Pasted%20image%2020221213194918.png)
*Figure 6; Check if an object is intersecting with a list of objects*
The function in figure 6 takes a list of game objects, a primary game object, and the radius of avoidance. Then checks if any of the list-objects are within the "centre’s" radius. If they are, then it will return a vector which can be applied to move the object away, and out of the radius. However, the calling is done for every "special" object, in relation to all trees on the map. Special objects are only portals and enemies, but would apply to any spawned object like chests or rare encounters. It then tries to do the same thing again until a given object has no trees within its radius.<br><br>*As I am writing this, I can see some glaring faults. Primarily, the return vector is the inverse of the distance between the closest tree and the given object. When it should’ve instead been the remaining distance to the maximum radius. However, another alternative to this function, would be to instead utilize the earlier mentioned "IsInPolygon" function. Though this function isn’t perfect, by utilizing the outline of where the trees are spawned, instead of the trees themselves, I could’ve saved a lot of processing.*

## Reflection
##### What i have learned
During this project I have learned a lot about game development. Aside from learning about Unity and C#, I have learned much about the process itself. My first lesson was to lower my expectations and set more realistic goals. As a group, we came into the project with very grand plans, and we learned quickly that they would likely be impossible. Mostly due to lack of time, because of other demanding projects, but also from lack of knowledge about Unity and the language.<br><br>When it comes to Unity it felt like I was learning new features and built-in systems at every step. Coming from developing in mostly C++ and Golang, this was quite a steep curve. However, as we progressed further into the project and I became more familiar with both C# and Unity, development went a lot smoother. I am very interested in trying to develop a game with unity again, as this was the most enjoyable project I have done so far. However, I would probably give myself more time and headspace than I had this semester.<br><br>**Version control & git**
Coming into this project I considered myself quite adept at using git with branches to avoid code conflicts. However, I found that Unity set the bar very high. Merging a scene conflict is effectively impossible and must instead be avoided at all costs. This goes for any changes done to a scene and/or prefab. I learnt that this was due to how unity assigns object IDs within its metadata. Nonetheless, as with every problem, there is a solution. Stashing the local scene somewhere smart, under a different name, then pulling the main-branch scene and manually merging in the local changes from the backup, worked great. This eliminated the merge conflict ID issues, since Unity will assign unique IDs locally that do not conflict with the main-branch IDs.<br><br>**Teamwork**
As for teamwork I feel we have done well. With mostly consistent meetings, and solid communication via discord, we ensured steady progress of the game. This together with a comprehensive Issue board where we delegated tasks and tracked progress. Made the development process one of the smoothest I have experienced so far.

##### What could have been done better
Personally, my biggest regret and lesson, is to not rely on other people’s code as a foundation, but rather construct my own from scratch. As mentioned in the [[Lisence note]], I ended up significantly changing the original code. However, since the foundation was built with a different intent, I could never get it to become mine or exactly what I wanted. The lack of direct ownership has been both stressing and frustrating. Looking back on it, I see that this was more of a hindrance than help. Bottom line is that with the knowledge I have aquired about C# during this project, I feel that I could have done a better job than the resulting product, if I had built it from scratch.<br><br>Another issue that could have been done better, were assets. Since I was mostly working with the automatic generation aspect of the program, I didn't focus on the asset part. By the time the MVP came around, we only had two proper textures, grass and trees. This is what lead to the homely houses, and later bushes, as well as the item shop. We should've probably split tasks better and begun searching for assets early on. However, as most of our members were more inclined to work on the code, fixing the substandard assets fell on the backburner and were simply tolerated. This expirience is something I will carry on to my next game developing project.