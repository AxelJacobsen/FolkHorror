## Weighting
|Description        |Score|
|-------------------|-----|
|Gameplay video     |15   |
|Code video         |0    |
|Good code          |15   |
|Bad code           |30   |
|Development process|20   |
|Reflection         |20   |
## Good code
Considering my weighting, it might not come as a suprise that i am dissatisfied with my overall code. Nonetheless, there were some parts i thought were good. For context, I had a goal of implementing the ability to progress through a "biome" in the form of changing generation setting and materials.  The reason for this was that other biomes will be handled by the same map generator. Thus there had to be ways to distinguish the biomes. To do this i decided to have stage generation "instructions", and a material communicator.<br>
##### Map generation settings
The map settings are stored in txt files corresponding with each stage of the biome. If there is no available file it will use the default settings which generate a medium sized balanced map. As of now, the forest biome progresses from stage 1-9  as the player approaches the mountain themed troll. The maps theme changes from deep forest, to savannah like dead forest, and finally, sparse highland. To create more or overwrite settings the developer can enter a new biome name into a new portal. Then they can adjust the generation settings in the inspector, hit F5 to refresh the generation so they may see how it looks. Then finally hit F8, to save the settings. Then enter the next stage, and do so for every level. This isnt perfect, but it works for our game as it is. If i were to rework it, i would change the system to instead take stage progression modifiers. Such that a developer can for example set a minimum enemies and a maximum enemies, and it will automatically lerp the amount of enemies depending on player progression and when the boss spawns.
##### Map material communication
The above system was developed very early, and at time of development it was of acceptable quality to me. However, changing the maps material was delayed, and therefore developed later, when i had gotten more experience.
![[Pasted image 20221213205133.png]]
Considering out lack of assets, I was certain i wanted to support hexadecimals as alternatives to textured materials. The values themselves are stored in three "MaterialAlts" structs within the "MapTextures" struct.  These are further placed into a list which is publicly available in the inspector. The progression is done liniarily from start to end of the biome, where element 0 is the start.
![[Pasted image 20221213205217.png]]
## Bad Code
Taking into consideration my minimal previous knowledge of Unity, and our ambitious project scope. It does not come as a suprise to me that quite a bit of bad code was created in an attempt to meet our deadlines. Overall i am not happy with the map generation part of the game program, but it mostly works as intended. However for object generation this is a different story. 
![[Pasted image 20221213193610.png]]
The above function is an example of this mess. Initially we get the lower and upper bounds of the polygon. This is a relatively efficient operation, but still not perfect. Then a Vector2 point is generated within these bounds. This is so that the object will spawn atleast within the same area. Then, we check if that point is within the given polygon. This funciton in and on its own is pretty inefficient due to having to identify the entire outline of the polygon to ensure the object isnt spawned inside a protrution in the mesh. If the point is outside the polygon, retry. It does this a maximum of **200** times. This is simply terrible and i hate it, however i see no clear alternative to the initial generation of the object. The *real* issue comes when ensuring that the newly spawned object isnt stuck inside a bunch of trees. Which has, depressingly enough, been solved in a similar way.![[Pasted image 20221213194918.png]]
The above code isn't the worst part, I would even consider it acceptable. It takes a list of gameobjects and a primary gameobject, as well as a radius. Checks if any of the objects are within the "center's" radius, if they are then it will return a vector which can be applied to move the object away out of the radius. However, the calling is done for every "special" object, in relation to all trees on the map. Special objects are only portals and enemies, but would apply to any spawned object like chests or rare encounters. It then tries to do the same thing again untill a given object has no trees within its radius. As i am writing this, i can see some glaring faults. Primarily, that the return vector is the inverse of the distance between the closest tree and the given object. When it shouldve been the remaining distance to the maximum radius. However, another alternative to this function as a whole would be to instead utilize the earlier mentioned function "IsInPolygon". Though this function isnt perfect, by utilizing the outline of where the trees are spawned, instead of the trees themselves, i couldve saved a lot of processing.


## Reflection
##### What i have learned
During this project i have learned a lot about game devlopment. Aside from learning about untiy and C#, i have learned a lot about the process itself. My first lesson was defintly to lower my excpectations, and set more realistic goals. As a group, we came into the project with very grand plans, and we learned quickly that they would likely be impossible. Mostly due to lack of time, because of other demanding projects, but also from lack of knowledge about Unity and the language. <br><br>When it comes to Unity it felt like i was learning new features and built-in systems at every step. Coming from developing in mostly C++ and golang, this was quite a steep curve. However, as we progressed further into the project and i became more familiar with both C# and Unity, development went a lot smoother. Im very interested in trying to develop a game with unity again, as this was defintly the most enjoyable project i have done so far. However, i would probably give myself more time and headspace than i had this semester.<br>
**What could be done better**<br>For me my biggest regret and lesson, is to not rely on other peoples code for a foundation, and rather construct my own from scratch. As mentioned in the [[Lisence note]], i ended up significantly changing the original code. However, since the foundation was built with a different intent, i could never get it to become mine or what i wanted. The lack of direct ownership has been both stressing and frustrating. Looking back on it i see that this was more of a hindrance than help. Bottom line is that with the knowledge i have about C# after this project, i feel like i couldve done a better job than the resulting product, if i had built it from scratch.<br><br>Another glaring issue that couldve been done better, were assets. Since i was mostly working with the automatic generation aspect of the program, i didn't focus on the asset part. By the time the MVP came around, we only had two propper textures, grass and trees. This is what lead to the homely houses, and later bushes as well as the item shop. We should've probably split tasks better, and begun searching for assets early on. However, as most of our members were more inclined to work on the code, fixing the substandard assets fell on the backburner and were simply tolerated. This is defintly something i will carry on to my next game developing project. <br><br>**Teamwork**
As for teamwork i feel like we have done well. With mostly consistent meetings, and solid communication via discord, we ensured steady progress of the game. This together with a comprehensive Issue board where we deligated tasks and tracked progress. Made the development process as  smooth as it could be.